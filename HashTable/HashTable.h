// Assignment #5
// Name: Uday Yalamanchili
// ASU Email Address: uyalaman@asu.edu

// Description: The below program builds our own custom data structure by defining the methods insertElement, 
// searchElement, changeElement, printable, constructor and destructor for the class HashTable.

// Hash Function: 
// I came up with my hash function using what professor has taught in class and trial-error method. 
// I tried several functions starting from the typically used ones. The typical methods gave me collisions
// much higher than the example provided in the question and sometimes it was in similar range. 

// I'm calculating the sum of ascii values of each character in the variable courseId provided by the user. 
// Lets take an example of two courses CSE310, EEE394. These courses along with their other permutations 
// (like CSE103, CSE301 etc.) have the same ASCII sum. So it'll will lead to a significant amount of avoidable collisions. 
// So I changed my hash function by initialising the sum variable to a random number between 0 and the size of the hash table
// (instead of initialising it to 0). This way the number of collisions were reduced by around 25%.


#include <iostream> //to use cout
#include <iomanip> //to format output
#include <string> //to use Ã§strings

using namespace std;

//struct Course represents course information
struct Course
{
    int credits, capacity, collision;
    string courseInfo, courseId, days, time;
};


//class HashTable will contain a class of course details
class HashTable
{
private:
    int size, cur_size;
    struct Course* dummy;

public:
    HashTable(int hashSize);
    ~HashTable();
    int hash1(string id, int asci);
    int hash2(string id, int asci);
    bool isFull();
    int insertElement(string id, int cred, int cap, string day, string time1, int size);
    void searchElement(string id);
    bool changeElement(string id, int cap);
    void printable();  
};


//Constructor to initialize the hash table with 'None' or 0 based on the datatype.
HashTable::HashTable(int hashSize)
{
    int cur_size = 0;
    this->size = hashSize;
    this->dummy = new Course[size];

    for(int i = 0; i < size; i++)
    {
        this->dummy[i] = Course();
        this->dummy[i].courseId = "None";
        this->dummy[i].collision = 0;
        this->dummy[i].credits = 0;
        this->dummy[i].capacity = 0;
        this->dummy[i].days = "None";
        this->dummy[i].time = "None";
    }
}
//Description: Destructor to delete every element in the hash table and free the memory
HashTable::~HashTable()
{
    delete[] dummy;
}

int HashTable::hash1(string id, int size)
{
    int sum = 0;
    int i = 0;

    for (i = 0; i < id.length(); i++)
    {
        sum = sum + (int) id[i];
    }

    return sum % size;
}

int HashTable::hash2(string id, int size)
{
    // We initialise our sum varibalr by generating a random number between 0 and size everytime its called.
    int sum = rand() % size;
    int i, j, k, prime_1 = 0;
    bool prime;

    // adding up the asci values of each character in the string id
    for (i = 0; i < id.length(); i++)
    {
        sum = sum + (int) id[i];
    }

    // Get the greatest prime number less than the given size
    for (j = size - 1; j > 1; j--)
    {
        prime = true;

        for (k = 2; k <= j-1; k++) 
        {
            if (j % k == 0) 
            {
                prime = false;
                break;
            }
        }

        if (prime == true)
        {
            prime_1 = j;
            break;
        }
    }

    return sum % prime_1;
}

bool HashTable::isFull()
{
    // if hash size reaches maximum size
    return (cur_size == size);
}


//Description: This method adds the new course information in the hash table based on the index generated by our hash functions.
int HashTable::insertElement(string id, int cred, int cap, string day, string time1, int size)
{
    int i, j = 0;

    if (isFull())
    {
        return 2;
    }

    int h1 = hash1(id, size);
    int h2 = hash2(id, size);
    
    for(i = 0; i < size; i++)
    {
        j = (h1 + h2 * i) % size;

        if (dummy[j].courseId == "None")
        {
            dummy[j].courseId = id;
            dummy[j].credits = cred;
            dummy[j].capacity = cap;
            dummy[j].days = day;
            dummy[j].time = time1;

            cur_size++;
            return 1;
            break;
        }
        else
        {
            dummy[j].collision++;
        }
    }
    return 0;
}


//Description: This method searches the hash table for a provided courseId by the user.
void HashTable::searchElement(string id)
{
    int h1 = hash1(id, size);
    int h2 = hash2(id, size);
    int i, j = 0;
    bool status = false;

    for(i = 0; i < size; i++)
    {
        j = (h1 + h2 * i) % size;
        if (dummy[j].courseId == id)
        {
            status = true;
            break;
        }
    }

    if (status == true)
    {
        cout << dummy[j].courseId << " found with credit(s) " << dummy[j].credits << ",  capacity " << dummy[j].capacity << " in the days: " << dummy[j].days << " and the time: " << dummy[j].time << "\n";
    }
    else
    {
        cout << id << " not found\n";
    }
}

//Description: This method changes the capacity information in the hash table for a provided courseId and capacity by the user.
bool HashTable::changeElement(string id, int cap)
{
    int h1 = hash1(id, size);
    int h2 = hash2(id, size);
    int i, j = 0;
    bool status = false;

    for(i = 0; i < size; i++)
    {
        j = (h1 + h2 * i) % size;
        if (dummy[j].courseId == id)
        {
            dummy[j].capacity = cap;
            status = true;
        }
    }

    return true;
}

//Description: This method helps print all the course information in the hash table
void HashTable::printable()
{
    int i = 0;

    cout << "index\tcollision\tCourseId\tCredits\t\tCapacity\tDays\t\tTime\n";
    for(i = 0; i < size; i++)
    { 
        cout << i << "\t" << dummy[i].collision << "\t\t" << dummy[i].courseId << "\t\t" << dummy[i].credits << "\t\t" << dummy[i].capacity << "\t\t" << dummy[i].days << "\t\t" << dummy[i].time << "\n";
    }
}
